#include "example.hpp"
#include "tinyrefl/visitor.hpp"
#include <tinyrefl/api.hpp>
#include <tinyrefl/class_visitor.hpp>
#include <tinyrefl/object_visitor.hpp>
#include "example.hpp.tinyrefl"

#include <iostream>

// Port of
// https://github.com/fair-acc/opencmw-cpp/blob/main/concepts/refl_cpp/refl_cpp_test.cpp
// to use the tinyrefl API. Here's a non-exaustive list of differences:
//
// - Due to how tinyrefl metadata generation works it is not possible to have
// both the user defined
// types and the reflection operations in the same file. Types must be
// declared in a separate header so the codegen tool is able to parse them.
// - An extra header "xxxx.tinyrefl" is required, this is the metadata header
// generated by the tool
// - The tinyefl API is object and member oriented. refl_cpp exposes data as
// constexpr objects too,
// but tinyrefl exposes properties as member functions (.has_metadata(),
// .has_attribute(), etc).
// - The tinyrefl API is designed around AST visitation. While there are
// high-level functions such as tinyrefl::visit_member_variables() that work on
// values directly, most AST visitors take "entities" (The objects representing
// reflection data of an specific entity in your sources) as input. The
// difference is that entity visitors are called-back on entities too (So you
// have access to all metadata), but value visitors like
// visit_member_variables() are called-back on the actual values:
//
//     tinyrefl::visit_class(tinyrefl::metadata<Test>(),
//     tinyrefl::member_variable_visitor([](const auto& memberEntity)) {
//         // memberEntity is a reference to the object in the tinyrefl
//         metadata containing info about the member variable
//     }));
//
//     Test test;
//
//     tinyrefl::visit_member_variables(test, [](auto& variable) {
//         // variable is a reference to the member variable of test
//     });
//
// - Tinyrefl supports reflection of used defined attributes, with those
// represented as constexpr classes that users should declare first in order to
// use the attribute:
//
//     namespace mylib {
//         struct serializable {
//             constexpr serializable(const bool on = true);
//         };
//     }
//
//     struct [[mylib::serializable]] DTO {
//         ...
//     };
//
// Attribute parameters are supported. Arguments are passed to the matching
// attribute class constexpr constructor:
//
//     struct [[mylib::serializable(false)]] Internal {
//         ...
//     };
//

template<typename T>
void serialize(std::ostream& os, T&& value)
{
    os << "\n{\n";
    bool add_comma = false;

    constexpr auto class_ = tinyrefl::metadata<std::decay_t<T>>();
    static_assert(class_.has_metadata());

    tinyrefl::visit_class(
        class_, tinyrefl::member_variable_visitor([&](const auto& member_) {
            constexpr std::decay_t<decltype(member_)> member;

            if constexpr(member.has_attribute(
                             "example_attributes::serializable"))
            {
                constexpr auto& serializable =
                    std::get<const example_attributes::serializable&>(
                        member.attribute_objects());

                if constexpr(serializable.on)
                {
                    if(add_comma)
                        os << ",\n";
                    os << "\"" << member.name() << "\":";
                    os << "\"" << member.get(value) << "\"";
                    add_comma = true;
                }
            }
        }));
    os << "\n}\n";
}

int main()
{
    example::Test test{.f = 1.0f, .i = 42, .s = "hello, world"};
    serialize(std::cout, test);
}
